import { app, BrowserWindow, session } from 'electron';
import installExtension, { REACT_DEVELOPER_TOOLS } from 'electron-devtools-installer';
import { ipcMain } from 'electron';
import net from 'net';
import dgram from 'dgram';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools only in development.
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(() => {
  // Set a more robust Content-Security-Policy
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self' 'unsafe-inline' data:; script-src 'self' 'unsafe-eval'; style-src-elem 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com"
        ],
      },
    });
  });

  installExtension(REACT_DEVELOPER_TOOLS)
    .then((name) => console.log(`Added Extension:  ${name}`))
    .catch((err) => console.log('An error occurred: ', err));

  createWindow();
});

// --- ACC Broadcast API (TCP) ---
const TCP_PORT = 9000;
const TCP_PASSWORD = 'asd';
let latestTcpTelemetry: any = {};
let tcpConnected = false;
let tcpError: string | null = null;
let tcpClient: net.Socket | null = null;
let reconnectTimeout: NodeJS.Timeout | null = null;

function connectToAccBroadcastApi() {
  if (tcpClient) {
    try { tcpClient.destroy(); } catch {}
    tcpClient = null;
  }
  if (reconnectTimeout) {
    clearTimeout(reconnectTimeout);
    reconnectTimeout = null;
  }
  tcpClient = new net.Socket();
  tcpClient.connect(TCP_PORT, '127.0.0.1', () => {
    console.log('Connected to ACC Broadcast API');
    tcpConnected = true;
    tcpError = null;
    tcpClient!.write(JSON.stringify({
      "command": "register",
      "connectionPassword": TCP_PASSWORD,
      "name": "ACC Companion"
    }) + '\r\n');
  });

  tcpClient.on('data', (data) => {
    try {
      const messages = data.toString().split('\r\n').filter(Boolean);
      for (const msg of messages) {
        const parsed = JSON.parse(msg);
        latestTcpTelemetry = parsed;
      }
    } catch (e) {
      console.error('Failed to parse ACC TCP data:', e);
    }
  });

  tcpClient.on('close', () => {
    console.log('Connection to ACC closed');
    tcpConnected = false;
    tcpError = 'Connection to ACC closed.';
    if (tcpClient) {
      try { tcpClient.destroy(); } catch {}
      tcpClient = null;
    }
    // Try to reconnect after a longer delay
    reconnectTimeout = setTimeout(connectToAccBroadcastApi, 10000);
  });

  tcpClient.on('error', (err) => {
    console.error('TCP connection error:', err.message);
    tcpConnected = false;
    tcpError = 'Cannot connect to ACC Broadcast API: ' + err.message;
    if (tcpClient) {
      try { tcpClient.destroy(); } catch {}
      tcpClient = null;
    }
    // Try to reconnect after a longer delay
    reconnectTimeout = setTimeout(connectToAccBroadcastApi, 10000);
  });
}

connectToAccBroadcastApi();

// --- ACC UDP Telemetry (if available) ---
const UDP_PORT = 5606; // Change if your UDP port is different
let latestUdpTelemetry: any = {};

try {
  const udpServer = dgram.createSocket('udp4');
  udpServer.on('message', (msg) => {
    // For now, just store the raw buffer
    latestUdpTelemetry = { raw: msg.toString('hex') };
  });
  udpServer.bind(UDP_PORT);
} catch (e) {
  console.error('UDP server error:', e);
}

// Add IPC handler for telemetry
ipcMain.handle('get-telemetry', async () => {
  // Prefer TCP data if available, otherwise show error or mock
  if (tcpError) {
    return { error: tcpError };
  }
  if (latestTcpTelemetry && Object.keys(latestTcpTelemetry).length > 0) {
    // Try to extract relevant fields from the broadcast API message
    if (latestTcpTelemetry.type === 'RealtimeCarUpdate' && latestTcpTelemetry.car) {
      return {
        fuel: latestTcpTelemetry.car.fuel,
        currentLapTime: latestTcpTelemetry.car.currentLapTime,
        completedLaps: latestTcpTelemetry.car.completedLaps,
        speed: latestTcpTelemetry.car.speedKmh
      };
    }
    if (Array.isArray(latestTcpTelemetry.cars)) {
      const playerCar = latestTcpTelemetry.cars.find((c: any) => c.isPlayerCar);
      if (playerCar) {
        return {
          fuel: playerCar.fuel,
          currentLapTime: playerCar.currentLapTime,
          completedLaps: playerCar.completedLaps,
          speed: playerCar.speedKmh
        };
      }
    }
    return latestTcpTelemetry;
  } else {
    return {
      fuel: 50.0,
      currentLapTime: 120.5,
      completedLaps: 10,
      speed: 180.0
    };
  }
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
